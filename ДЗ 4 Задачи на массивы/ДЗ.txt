Домашнее задание
Задачи на массивы

Цель:
написать первую программу на Ассемблере.


Описание/Пошаговая инструкция выполнения домашнего задания:
Решите одну из трёх алгоритмических задач (см. скрипт к занятию).

Для решения выбрана Задача 1: самая длинная последовательность:
    Дан массив, который состоит из нулей и единиц. Выведите размер самой длинной непрерывной последовательности единиц в массиве.
    Пример: [0, 0, 1, 0, 1, 1, 1, 0]
    Ответ:  3
    Пример: [0, 0, 0]
    Ответ:  0
    **Ограничения:**
    - 0 < n < 50, где n — длина массива
    - массив состоит только из чисел 0 и 1

    %include 'library.asm'
    section .data
        arr dd  0, 0, 1, 0, 1, 1, 1, 0
        n   dd  8

    section .text
        global _start

    _start:

        ; Ваш код

        call print_number
        call exit

-------------- РЕШЕНИЕ
%include 'library.asm'

section .data
    ; arr массив чисел
    arr dd 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    n dd 50             ; кол-во элементов в массиве arr

section .text
    global _start

_start:
    xor eax, eax        ; eax = 0
    mov ecx, arr        ; адрес начала массива

    mov ebx, arr        ; ebx = адрес arr
    mov eax, [n]        ; eax = n
    dec eax             ; eax = n-1
    imul eax, 4         ; eax = 4*(n-1)
    add ebx, eax        ; ebx = arr + 4*(n-1) адрес 0-го байта последнего элемента массива
    xor eax, eax        ; eax = 0
    mov edx, -1         ; edx = -1,  элемент массива считанный в предыдущей итерации (-1 предыдущих не было)
    mov esi, 1          ; длина текущей последовательности
    mov edi, 1          ; итог - кол-во элементов в самой длинной повторяющейся последовательности
    jmp cycle1          ; переход к основному циклу

decrease_esi:
   mov esi, 1
   jmp next             ; продолжаем цикл

cycle1:                 ; цикл по элементам массива от последнего к первому

    mov eax, [ebx]      ; eax = значение текущего элемента массива
    ;call print_number   ; вывод  на экран того что в eax
    sub ebx, 4          ; уменьшение адреса тек. элемента массива на 4 байта
    cmp eax, edx        ; сравниваем текущий элемент массива с предыдущим элементом
    jne decrease_esi    ; eax <> edx, предыдущий  <>  текущему, уменьшаем длину текущей помледовательности и идем дальше
    inc esi             ; совпали, увеличение счетчика тек. последовательности
    cmp esi, edi        ; сравниваем с итогом
    jle next            ; esi =< edi, тек. длина последовательности  =< итогу
    inc edi             ; больше, увеличиваем итог
next:
    mov edx, eax        ; соханяем предыдущий элемент массива
    cmp ebx, ecx        ; проверка на выход из цикла - сравнение адреса тек. элемента массива с адресом нулевого элемента массива
    jge cycle1          ; if (ebx > arr) goto cycle1 условие выполнения итерации цикла



    mov eax, edi        ; выводим итог в eax
    call print_number   ; вывод  на экран того что в eax
    call exit           ; выход из программы
